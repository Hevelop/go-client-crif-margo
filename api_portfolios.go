/*
Global Marketing Solution

## Overview

API version: 1.0.0
Contact: PM_Margo@crif.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package crifmargo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type PortfoliosAPI interface {

	/*
	DeletePortfolio Delete a portfolio

	Retrieves the values of a `Portfolio` identified by portfolioId and it delete the whole portfolio.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
	@return PortfoliosAPIDeletePortfolioRequest
	*/
	DeletePortfolio(ctx context.Context, portfolioId string) PortfoliosAPIDeletePortfolioRequest

	// DeletePortfolioExecute executes the request
	DeletePortfolioExecute(r PortfoliosAPIDeletePortfolioRequest) (*http.Response, error)

	/*
	DeleteSharingPortfolio Delete Sharing a Portfolio

	Retrieves the values of a `Portfolio` identified by portfolioId and it deletes all its existing sharing with the Web Users organization.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
	@return PortfoliosAPIDeleteSharingPortfolioRequest
	*/
	DeleteSharingPortfolio(ctx context.Context, portfolioId string) PortfoliosAPIDeleteSharingPortfolioRequest

	// DeleteSharingPortfolioExecute executes the request
	DeleteSharingPortfolioExecute(r PortfoliosAPIDeleteSharingPortfolioRequest) (*http.Response, error)

	/*
	GetPortfolio Get a portfolio

	Retrieves the values of a `Portfolio` identified by portfolioId and it retrieves the details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
	@return PortfoliosAPIGetPortfolioRequest
	*/
	GetPortfolio(ctx context.Context, portfolioId string) PortfoliosAPIGetPortfolioRequest

	// GetPortfolioExecute executes the request
	//  @return PortfolioType
	GetPortfolioExecute(r PortfoliosAPIGetPortfolioRequest) (*PortfolioType, *http.Response, error)

	/*
	GetPortfolios List all portfolios

	The method retrieves the list of created `Portfolio` by the organization. The response could contain also portfolios created by the web users that belong to the organization (based on the authorization).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PortfoliosAPIGetPortfoliosRequest
	*/
	GetPortfolios(ctx context.Context) PortfoliosAPIGetPortfoliosRequest

	// GetPortfoliosExecute executes the request
	//  @return PortfolioSummaryArrayMetadataType
	GetPortfoliosExecute(r PortfoliosAPIGetPortfoliosRequest) (*PortfolioSummaryArrayMetadataType, *http.Response, error)

	/*
	PortfolioSharesDelete Delete Portfolio shares

	The purpose of this method is to delete sharing for one or more offices.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
	@return PortfoliosAPIPortfolioSharesDeleteRequest
	*/
	PortfolioSharesDelete(ctx context.Context, portfolioId string) PortfoliosAPIPortfolioSharesDeleteRequest

	// PortfolioSharesDeleteExecute executes the request
	PortfolioSharesDeleteExecute(r PortfoliosAPIPortfolioSharesDeleteRequest) (*http.Response, error)

	/*
	PortfolioSharingList Share a Portfolio

	Retrieves the sharing to Web Users' organization of a `Portfolio` and shows which access type is allow to web users.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
	@return PortfoliosAPIPortfolioSharingListRequest
	*/
	PortfolioSharingList(ctx context.Context, portfolioId string) PortfoliosAPIPortfolioSharingListRequest

	// PortfolioSharingListExecute executes the request
	//  @return []AccessRight
	PortfolioSharingListExecute(r PortfoliosAPIPortfolioSharingListRequest) ([]AccessRight, *http.Response, error)

	/*
	PostAddPortfolioCompanies Add companies to portfolio

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
	@return PortfoliosAPIPostAddPortfolioCompaniesRequest
	*/
	PostAddPortfolioCompanies(ctx context.Context, portfolioId string) PortfoliosAPIPostAddPortfolioCompaniesRequest

	// PostAddPortfolioCompaniesExecute executes the request
	//  @return []CompanyResultType
	PostAddPortfolioCompaniesExecute(r PortfoliosAPIPostAddPortfolioCompaniesRequest) ([]CompanyResultType, *http.Response, error)

	/*
	PostDeletePortfolioCompanies Delete companies from portfolio

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
	@return PortfoliosAPIPostDeletePortfolioCompaniesRequest
	*/
	PostDeletePortfolioCompanies(ctx context.Context, portfolioId string) PortfoliosAPIPostDeletePortfolioCompaniesRequest

	// PostDeletePortfolioCompaniesExecute executes the request
	//  @return []CompanyResultType
	PostDeletePortfolioCompaniesExecute(r PortfoliosAPIPostDeletePortfolioCompaniesRequest) ([]CompanyResultType, *http.Response, error)

	/*
	PostPortfolioDownload Download portfolio

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
	@return PortfoliosAPIPostPortfolioDownloadRequest
	*/
	PostPortfolioDownload(ctx context.Context, portfolioId string) PortfoliosAPIPostPortfolioDownloadRequest

	// PostPortfolioDownloadExecute executes the request
	//  @return DownloadResultType
	PostPortfolioDownloadExecute(r PortfoliosAPIPostPortfolioDownloadRequest) (*DownloadResultType, *http.Response, error)

	/*
	PostPortfolios Create portfolio

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PortfoliosAPIPostPortfoliosRequest
	*/
	PostPortfolios(ctx context.Context) PortfoliosAPIPostPortfoliosRequest

	// PostPortfoliosExecute executes the request
	//  @return PortfolioSummaryType
	PostPortfoliosExecute(r PortfoliosAPIPostPortfoliosRequest) (*PortfolioSummaryType, *http.Response, error)

	/*
	PostSimilarity Generate prospect based on own portfolio

	Similarity API provides in output a subset of **filters** parameter identified by the algorithm and that should be used in the method **POST /prospecting/search**.

The input parameters are:
* `portfolioId`
* `companyPortfolioStatus`

If you would like to use this method you should:
1. Identify the portfolio on which you would like to generate prospects. For this, you can use the method **GET /portfolios** in order to choose the starting portfolio and, based on you chose, you can find the **portfolioId** parameter.
2. Identify companies segment belonging to a portfolio selected. In this case, you can use the **portfolioId** found in the previously step and, using the method **GET /portfolios/{portfolioId}/** you can see how companies are divided by portfolio status. Based on statistics, you can select the *companyPortfolioStatus* parameter.

Ther response provides two information:
* filters: it contains **filters** parameter identified by the algorithm. It should be used in the **POST /prospecting/search**.
* totalElements: it's the  total number of companies that satisfy the prospecting query.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
	@return PortfoliosAPIPostSimilarityRequest
	*/
	PostSimilarity(ctx context.Context, portfolioId string) PortfoliosAPIPostSimilarityRequest

	// PostSimilarityExecute executes the request
	//  @return SimilarityResultType
	PostSimilarityExecute(r PortfoliosAPIPostSimilarityRequest) (*SimilarityResultType, *http.Response, error)

	/*
	PostUpdatePortfolioCompanies Update companies to portfolio

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
	@return PortfoliosAPIPostUpdatePortfolioCompaniesRequest
	*/
	PostUpdatePortfolioCompanies(ctx context.Context, portfolioId string) PortfoliosAPIPostUpdatePortfolioCompaniesRequest

	// PostUpdatePortfolioCompaniesExecute executes the request
	//  @return []CompanyResultType
	PostUpdatePortfolioCompaniesExecute(r PortfoliosAPIPostUpdatePortfolioCompaniesRequest) ([]CompanyResultType, *http.Response, error)

	/*
	SharePortfolio Share a Portfolio

	The purpose of this method is to share a `Portfolio` created by API user to the whole Web Users that belongs into offices of own organization.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
	@return PortfoliosAPISharePortfolioRequest
	*/
	SharePortfolio(ctx context.Context, portfolioId string) PortfoliosAPISharePortfolioRequest

	// SharePortfolioExecute executes the request
	SharePortfolioExecute(r PortfoliosAPISharePortfolioRequest) (*http.Response, error)
}

// PortfoliosAPIService PortfoliosAPI service
type PortfoliosAPIService service

type PortfoliosAPIDeletePortfolioRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	portfolioId string
}

func (r PortfoliosAPIDeletePortfolioRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePortfolioExecute(r)
}

/*
DeletePortfolio Delete a portfolio

Retrieves the values of a `Portfolio` identified by portfolioId and it delete the whole portfolio.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
 @return PortfoliosAPIDeletePortfolioRequest
*/
func (a *PortfoliosAPIService) DeletePortfolio(ctx context.Context, portfolioId string) PortfoliosAPIDeletePortfolioRequest {
	return PortfoliosAPIDeletePortfolioRequest{
		ApiService: a,
		ctx: ctx,
		portfolioId: portfolioId,
	}
}

// Execute executes the request
func (a *PortfoliosAPIService) DeletePortfolioExecute(r PortfoliosAPIDeletePortfolioRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.DeletePortfolio")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios/{portfolioId}"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolioId"+"}", url.PathEscape(parameterValueToString(r.portfolioId, "portfolioId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PortfoliosAPIDeleteSharingPortfolioRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	portfolioId string
}

func (r PortfoliosAPIDeleteSharingPortfolioRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSharingPortfolioExecute(r)
}

/*
DeleteSharingPortfolio Delete Sharing a Portfolio

Retrieves the values of a `Portfolio` identified by portfolioId and it deletes all its existing sharing with the Web Users organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
 @return PortfoliosAPIDeleteSharingPortfolioRequest
*/
func (a *PortfoliosAPIService) DeleteSharingPortfolio(ctx context.Context, portfolioId string) PortfoliosAPIDeleteSharingPortfolioRequest {
	return PortfoliosAPIDeleteSharingPortfolioRequest{
		ApiService: a,
		ctx: ctx,
		portfolioId: portfolioId,
	}
}

// Execute executes the request
func (a *PortfoliosAPIService) DeleteSharingPortfolioExecute(r PortfoliosAPIDeleteSharingPortfolioRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.DeleteSharingPortfolio")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios/{portfolioId}/share"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolioId"+"}", url.PathEscape(parameterValueToString(r.portfolioId, "portfolioId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PortfoliosAPIGetPortfolioRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	portfolioId string
}

func (r PortfoliosAPIGetPortfolioRequest) Execute() (*PortfolioType, *http.Response, error) {
	return r.ApiService.GetPortfolioExecute(r)
}

/*
GetPortfolio Get a portfolio

Retrieves the values of a `Portfolio` identified by portfolioId and it retrieves the details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
 @return PortfoliosAPIGetPortfolioRequest
*/
func (a *PortfoliosAPIService) GetPortfolio(ctx context.Context, portfolioId string) PortfoliosAPIGetPortfolioRequest {
	return PortfoliosAPIGetPortfolioRequest{
		ApiService: a,
		ctx: ctx,
		portfolioId: portfolioId,
	}
}

// Execute executes the request
//  @return PortfolioType
func (a *PortfoliosAPIService) GetPortfolioExecute(r PortfoliosAPIGetPortfolioRequest) (*PortfolioType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PortfolioType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.GetPortfolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios/{portfolioId}"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolioId"+"}", url.PathEscape(parameterValueToString(r.portfolioId, "portfolioId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PortfoliosAPIGetPortfoliosRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	page *int64
	size *int64
}

// Zero-based number of the page to obtain
func (r PortfoliosAPIGetPortfoliosRequest) Page(page int64) PortfoliosAPIGetPortfoliosRequest {
	r.page = &page
	return r
}

// It manages the maximum number of elements inside a response. Maximum can&#39;t be more than 100.
func (r PortfoliosAPIGetPortfoliosRequest) Size(size int64) PortfoliosAPIGetPortfoliosRequest {
	r.size = &size
	return r
}

func (r PortfoliosAPIGetPortfoliosRequest) Execute() (*PortfolioSummaryArrayMetadataType, *http.Response, error) {
	return r.ApiService.GetPortfoliosExecute(r)
}

/*
GetPortfolios List all portfolios

The method retrieves the list of created `Portfolio` by the organization. The response could contain also portfolios created by the web users that belong to the organization (based on the authorization).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PortfoliosAPIGetPortfoliosRequest
*/
func (a *PortfoliosAPIService) GetPortfolios(ctx context.Context) PortfoliosAPIGetPortfoliosRequest {
	return PortfoliosAPIGetPortfoliosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PortfolioSummaryArrayMetadataType
func (a *PortfoliosAPIService) GetPortfoliosExecute(r PortfoliosAPIGetPortfoliosRequest) (*PortfolioSummaryArrayMetadataType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PortfolioSummaryArrayMetadataType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.GetPortfolios")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int64 = 0
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int64 = 15
		r.size = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PortfoliosAPIPortfolioSharesDeleteRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	portfolioId string
	officesList *OfficesList
}

// Office ids for which is asking to delete the portfolio share
func (r PortfoliosAPIPortfolioSharesDeleteRequest) OfficesList(officesList OfficesList) PortfoliosAPIPortfolioSharesDeleteRequest {
	r.officesList = &officesList
	return r
}

func (r PortfoliosAPIPortfolioSharesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PortfolioSharesDeleteExecute(r)
}

/*
PortfolioSharesDelete Delete Portfolio shares

The purpose of this method is to delete sharing for one or more offices.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
 @return PortfoliosAPIPortfolioSharesDeleteRequest
*/
func (a *PortfoliosAPIService) PortfolioSharesDelete(ctx context.Context, portfolioId string) PortfoliosAPIPortfolioSharesDeleteRequest {
	return PortfoliosAPIPortfolioSharesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		portfolioId: portfolioId,
	}
}

// Execute executes the request
func (a *PortfoliosAPIService) PortfolioSharesDeleteExecute(r PortfoliosAPIPortfolioSharesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.PortfolioSharesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios/{portfolioId}/shares/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolioId"+"}", url.PathEscape(parameterValueToString(r.portfolioId, "portfolioId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.officesList
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PortfoliosAPIPortfolioSharingListRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	portfolioId string
}

func (r PortfoliosAPIPortfolioSharingListRequest) Execute() ([]AccessRight, *http.Response, error) {
	return r.ApiService.PortfolioSharingListExecute(r)
}

/*
PortfolioSharingList Share a Portfolio

Retrieves the sharing to Web Users' organization of a `Portfolio` and shows which access type is allow to web users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
 @return PortfoliosAPIPortfolioSharingListRequest
*/
func (a *PortfoliosAPIService) PortfolioSharingList(ctx context.Context, portfolioId string) PortfoliosAPIPortfolioSharingListRequest {
	return PortfoliosAPIPortfolioSharingListRequest{
		ApiService: a,
		ctx: ctx,
		portfolioId: portfolioId,
	}
}

// Execute executes the request
//  @return []AccessRight
func (a *PortfoliosAPIService) PortfolioSharingListExecute(r PortfoliosAPIPortfolioSharingListRequest) ([]AccessRight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AccessRight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.PortfolioSharingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios/{portfolioId}/share"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolioId"+"}", url.PathEscape(parameterValueToString(r.portfolioId, "portfolioId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PortfoliosAPIPostAddPortfolioCompaniesRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	portfolioId string
	companyArrayType *CompanyArrayType
}

// Add one or more companies to an existing portfolio.  &#x60;companies&#x60; list needs to have maximum 100 objects per call and each object belonging to a list must contain the company&#39;s information to upload in the portfolio.  The service is able to upload the headquarter or the branch data. The data upload depends by the values reported in each object: * if the object contains only the **identificationCode** the system upload only the headquarter data. * if the object contains the **identificationCode** and the **companyUnitId** the system upload only the branch data.  Values reported in the &#x60;value&#x60; items (customVariable array) shall respect the data type defined in the **POST /portfolios**.  &#x60;margoId&#x60; and &#x60;isEnriched&#x60; are read-only fields and must not be provided in input. &#x60;margoId&#x60; is generated by Margo system during the company upload in order to identify a company inside portfolio. &#x60;isEnriched&#x60; indicate if a company is enriched or not.
func (r PortfoliosAPIPostAddPortfolioCompaniesRequest) CompanyArrayType(companyArrayType CompanyArrayType) PortfoliosAPIPostAddPortfolioCompaniesRequest {
	r.companyArrayType = &companyArrayType
	return r
}

func (r PortfoliosAPIPostAddPortfolioCompaniesRequest) Execute() ([]CompanyResultType, *http.Response, error) {
	return r.ApiService.PostAddPortfolioCompaniesExecute(r)
}

/*
PostAddPortfolioCompanies Add companies to portfolio

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
 @return PortfoliosAPIPostAddPortfolioCompaniesRequest
*/
func (a *PortfoliosAPIService) PostAddPortfolioCompanies(ctx context.Context, portfolioId string) PortfoliosAPIPostAddPortfolioCompaniesRequest {
	return PortfoliosAPIPostAddPortfolioCompaniesRequest{
		ApiService: a,
		ctx: ctx,
		portfolioId: portfolioId,
	}
}

// Execute executes the request
//  @return []CompanyResultType
func (a *PortfoliosAPIService) PostAddPortfolioCompaniesExecute(r PortfoliosAPIPostAddPortfolioCompaniesRequest) ([]CompanyResultType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CompanyResultType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.PostAddPortfolioCompanies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios/{portfolioId}/companies/bulk-add"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolioId"+"}", url.PathEscape(parameterValueToString(r.portfolioId, "portfolioId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyArrayType == nil {
		return localVarReturnValue, nil, reportError("companyArrayType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.companyArrayType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []CompanyResultType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PortfoliosAPIPostDeletePortfolioCompaniesRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	portfolioId string
	companyMargoIdArrayType *CompanyMargoIdArrayType
}

// Based on portfolioId parameter Margo delete a subset of companies belongs to the related portfolio.  The json body to provide is an array with &#x60;margoId&#x60; associated an each company belongs to the portfolio.  The margoIds are available with the method **POST /portfolios/{portfolioId}/download** (data packet: **portfolioInfo**).
func (r PortfoliosAPIPostDeletePortfolioCompaniesRequest) CompanyMargoIdArrayType(companyMargoIdArrayType CompanyMargoIdArrayType) PortfoliosAPIPostDeletePortfolioCompaniesRequest {
	r.companyMargoIdArrayType = &companyMargoIdArrayType
	return r
}

func (r PortfoliosAPIPostDeletePortfolioCompaniesRequest) Execute() ([]CompanyResultType, *http.Response, error) {
	return r.ApiService.PostDeletePortfolioCompaniesExecute(r)
}

/*
PostDeletePortfolioCompanies Delete companies from portfolio

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
 @return PortfoliosAPIPostDeletePortfolioCompaniesRequest
*/
func (a *PortfoliosAPIService) PostDeletePortfolioCompanies(ctx context.Context, portfolioId string) PortfoliosAPIPostDeletePortfolioCompaniesRequest {
	return PortfoliosAPIPostDeletePortfolioCompaniesRequest{
		ApiService: a,
		ctx: ctx,
		portfolioId: portfolioId,
	}
}

// Execute executes the request
//  @return []CompanyResultType
func (a *PortfoliosAPIService) PostDeletePortfolioCompaniesExecute(r PortfoliosAPIPostDeletePortfolioCompaniesRequest) ([]CompanyResultType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CompanyResultType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.PostDeletePortfolioCompanies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios/{portfolioId}/companies/bulk-delete"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolioId"+"}", url.PathEscape(parameterValueToString(r.portfolioId, "portfolioId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyMargoIdArrayType == nil {
		return localVarReturnValue, nil, reportError("companyMargoIdArrayType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.companyMargoIdArrayType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PortfoliosAPIPostPortfolioDownloadRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	portfolioId string
	acceptLanguage *string
	downloadType *DownloadType
}

// Set here the language you want in output
func (r PortfoliosAPIPostPortfolioDownloadRequest) AcceptLanguage(acceptLanguage string) PortfoliosAPIPostPortfolioDownloadRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// This method allows to download the business information of all companies content in the portfolio or of a subset of it.  Margo retrives the data based on two values: * The parameter &#x60;portfolioId&#x60;: the guid is generated automatically by the system after the portfolio creation and it identifies uniquely the portfolio in the system. The &#x60;portfolioId&#x60; of the created portfolios are available using the method **GET /portfolios**.    * The value specified in the object &#x60;content&#x60; reported in the request body. The key must be one of &#x60;dataPacketList&#x60; or &#x60;marketingList&#x60;. The first one is an array and each value must be the dataPacketId  (for more details of the data packet availables go to the page **https://developer-cms.crifnet.com:8080/apis/margo/_**). &#x60;marketingList&#x60; enables the download of the company data with a fixed layout and it must be a string with a specific value (e.g. **marketing**).  Moreover the method returns the business information for the whole portfolio indicated or for a subset of it.            Margo retrives data of a subset of whole portfolio throught the query parameters specify inside the request body. There are two type of parameters in the request body: * &#x60;filters&#x60;: it contains all filter parameters linked to the companies&#39; business information. Parameters are grouped based on the data type: **numericFilters**, **dateFilters**, **booleanFilters**, **stringFilters**, **domainFilters**. * &#x60;portfolioFilters&#x60;: it contains all portfolio&#39;s filter parameters associated to the companies that it contains. Based on the definition in **POST /portfolios**, custom variables are grouped based on data type: **numericFilters**, **dateFilters**, **stringFilters**.  Another important parameter that handle API&#39;s response is **continueToken**: it manages the number of calls based on the total number of companies in the portfolio and the pagination reported in the body of this method. The continueToken is provided after first call by Margo and it must be inserted in the body of next request. Moreover, it must be updated in the request body with the token returned by the previous response as it changes so as to identify each paginated response.  **Use case**:The CRM system needs to download the data packet **address** for a subset of the whole portfolio and it should consider only the companies localized in the province of Rome and with employees in the range 1-50.
func (r PortfoliosAPIPostPortfolioDownloadRequest) DownloadType(downloadType DownloadType) PortfoliosAPIPostPortfolioDownloadRequest {
	r.downloadType = &downloadType
	return r
}

func (r PortfoliosAPIPostPortfolioDownloadRequest) Execute() (*DownloadResultType, *http.Response, error) {
	return r.ApiService.PostPortfolioDownloadExecute(r)
}

/*
PostPortfolioDownload Download portfolio

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
 @return PortfoliosAPIPostPortfolioDownloadRequest
*/
func (a *PortfoliosAPIService) PostPortfolioDownload(ctx context.Context, portfolioId string) PortfoliosAPIPostPortfolioDownloadRequest {
	return PortfoliosAPIPostPortfolioDownloadRequest{
		ApiService: a,
		ctx: ctx,
		portfolioId: portfolioId,
	}
}

// Execute executes the request
//  @return DownloadResultType
func (a *PortfoliosAPIService) PostPortfolioDownloadExecute(r PortfoliosAPIPostPortfolioDownloadRequest) (*DownloadResultType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DownloadResultType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.PostPortfolioDownload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios/{portfolioId}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolioId"+"}", url.PathEscape(parameterValueToString(r.portfolioId, "portfolioId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.downloadType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PortfoliosAPIPostPortfoliosRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	portfolioCreationType *PortfolioCreationType
}

// This method allows to create a &#x60;Portfolio&#x60;.   The JSON body could contain the following fields: * name: it contains the name of the portfolio (the field must be unique and it&#39;s mandatory). * customVariables: this array shall contain the information for custom variables present in the portfolio (the field is not mandatory).  Information for the portfolios&#39; custom variables: * There can be at max 6 custom variables inside the portfolio and the number is handled by the &#x60;index&#x60; item. The values accepted are from 0 to 5.  * Custom variable &#x60;name&#x60; must be unique in the portfolio. * The &#x60;type&#x60; must be one of the following: String, Number, Date.  This method allow only the portfolio creation. The addition of companies is handled by a different method: **POST /portfolios/{portfolioId}/companies**.  **Use case:** The CRM system needs to create a portfolio in Margo whit the own customer base. It would identifies this portfolio with name OwnCustomerBase and he would to create two custom variables: * Customer segment: it describes the customer segment class according to revenue volume. * Quantity purchased: it determines the quantity of product sold to the customer.
func (r PortfoliosAPIPostPortfoliosRequest) PortfolioCreationType(portfolioCreationType PortfolioCreationType) PortfoliosAPIPostPortfoliosRequest {
	r.portfolioCreationType = &portfolioCreationType
	return r
}

func (r PortfoliosAPIPostPortfoliosRequest) Execute() (*PortfolioSummaryType, *http.Response, error) {
	return r.ApiService.PostPortfoliosExecute(r)
}

/*
PostPortfolios Create portfolio

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PortfoliosAPIPostPortfoliosRequest
*/
func (a *PortfoliosAPIService) PostPortfolios(ctx context.Context) PortfoliosAPIPostPortfoliosRequest {
	return PortfoliosAPIPostPortfoliosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PortfolioSummaryType
func (a *PortfoliosAPIService) PostPortfoliosExecute(r PortfoliosAPIPostPortfoliosRequest) (*PortfolioSummaryType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PortfolioSummaryType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.PostPortfolios")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.portfolioCreationType == nil {
		return localVarReturnValue, nil, reportError("portfolioCreationType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.portfolioCreationType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PortfoliosAPIPostSimilarityRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	portfolioId string
	companyPortfolioStatus *string
}

// It indicates one of company portfolio status available in own portfolio.
func (r PortfoliosAPIPostSimilarityRequest) CompanyPortfolioStatus(companyPortfolioStatus string) PortfoliosAPIPostSimilarityRequest {
	r.companyPortfolioStatus = &companyPortfolioStatus
	return r
}

func (r PortfoliosAPIPostSimilarityRequest) Execute() (*SimilarityResultType, *http.Response, error) {
	return r.ApiService.PostSimilarityExecute(r)
}

/*
PostSimilarity Generate prospect based on own portfolio

Similarity API provides in output a subset of **filters** parameter identified by the algorithm and that should be used in the method **POST /prospecting/search**.

The input parameters are:
* `portfolioId`
* `companyPortfolioStatus`

If you would like to use this method you should:
1. Identify the portfolio on which you would like to generate prospects. For this, you can use the method **GET /portfolios** in order to choose the starting portfolio and, based on you chose, you can find the **portfolioId** parameter.
2. Identify companies segment belonging to a portfolio selected. In this case, you can use the **portfolioId** found in the previously step and, using the method **GET /portfolios/{portfolioId}/** you can see how companies are divided by portfolio status. Based on statistics, you can select the *companyPortfolioStatus* parameter.

Ther response provides two information:
* filters: it contains **filters** parameter identified by the algorithm. It should be used in the **POST /prospecting/search**.
* totalElements: it's the  total number of companies that satisfy the prospecting query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
 @return PortfoliosAPIPostSimilarityRequest
*/
func (a *PortfoliosAPIService) PostSimilarity(ctx context.Context, portfolioId string) PortfoliosAPIPostSimilarityRequest {
	return PortfoliosAPIPostSimilarityRequest{
		ApiService: a,
		ctx: ctx,
		portfolioId: portfolioId,
	}
}

// Execute executes the request
//  @return SimilarityResultType
func (a *PortfoliosAPIService) PostSimilarityExecute(r PortfoliosAPIPostSimilarityRequest) (*SimilarityResultType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimilarityResultType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.PostSimilarity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios/{portfolioId}/create-similarity"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolioId"+"}", url.PathEscape(parameterValueToString(r.portfolioId, "portfolioId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyPortfolioStatus == nil {
		return localVarReturnValue, nil, reportError("companyPortfolioStatus is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "companyPortfolioStatus", r.companyPortfolioStatus, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PortfoliosAPIPostUpdatePortfolioCompaniesRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	portfolioId string
	companyUpdateArrayType *CompanyUpdateArrayType
}

// The service updates one or more companies of an existing portfolio. The information that is possible to update are only the portfolio information: companyPortfolioStatus, tags, amount, areaManagerId, salesId, productId and customVariables’ value.  The key field in order to allow the update of company data in the portfolio is the &#x60;margoId&#x60; - this information is available for each company belongs to the portfolio using the method **POST /portfolios/{portfolioId}/download** (data packet: **portfolioInfo**).  &#x60;companies&#x60; list needs to have maximum 100 objects per call and each object belonging to a list must contain, for each company, at least the fileds: margoId, identificationCode and companyPortfolioStatus.  &#x60;isEnriched&#x60; is read-only fields and must not be provided in input. These items are generated by Margo system  and it indicate if a company is enrinched or not.
func (r PortfoliosAPIPostUpdatePortfolioCompaniesRequest) CompanyUpdateArrayType(companyUpdateArrayType CompanyUpdateArrayType) PortfoliosAPIPostUpdatePortfolioCompaniesRequest {
	r.companyUpdateArrayType = &companyUpdateArrayType
	return r
}

func (r PortfoliosAPIPostUpdatePortfolioCompaniesRequest) Execute() ([]CompanyResultType, *http.Response, error) {
	return r.ApiService.PostUpdatePortfolioCompaniesExecute(r)
}

/*
PostUpdatePortfolioCompanies Update companies to portfolio

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
 @return PortfoliosAPIPostUpdatePortfolioCompaniesRequest
*/
func (a *PortfoliosAPIService) PostUpdatePortfolioCompanies(ctx context.Context, portfolioId string) PortfoliosAPIPostUpdatePortfolioCompaniesRequest {
	return PortfoliosAPIPostUpdatePortfolioCompaniesRequest{
		ApiService: a,
		ctx: ctx,
		portfolioId: portfolioId,
	}
}

// Execute executes the request
//  @return []CompanyResultType
func (a *PortfoliosAPIService) PostUpdatePortfolioCompaniesExecute(r PortfoliosAPIPostUpdatePortfolioCompaniesRequest) ([]CompanyResultType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CompanyResultType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.PostUpdatePortfolioCompanies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios/{portfolioId}/companies/bulk-update"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolioId"+"}", url.PathEscape(parameterValueToString(r.portfolioId, "portfolioId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyUpdateArrayType == nil {
		return localVarReturnValue, nil, reportError("companyUpdateArrayType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.companyUpdateArrayType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []CompanyResultType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PortfoliosAPISharePortfolioRequest struct {
	ctx context.Context
	ApiService PortfoliosAPI
	portfolioId string
	accessRight *AccessRight
}

// &#x60;accessRight&#x60; defines which operation can be done by web users for portfolio received. Values can be one of: - **Read**: it doesn’t allow to edit the API portfolio to web users but they can see inside the platform in read only way - **Write**: it allows to see and edit the API’s portfolio to all web users
func (r PortfoliosAPISharePortfolioRequest) AccessRight(accessRight AccessRight) PortfoliosAPISharePortfolioRequest {
	r.accessRight = &accessRight
	return r
}

func (r PortfoliosAPISharePortfolioRequest) Execute() (*http.Response, error) {
	return r.ApiService.SharePortfolioExecute(r)
}

/*
SharePortfolio Share a Portfolio

The purpose of this method is to share a `Portfolio` created by API user to the whole Web Users that belongs into offices of own organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param portfolioId It is a `Portfolio`'s unique identifier. It must contains the portfolio's identifier indicated in  the method **GET /portfolios**.
 @return PortfoliosAPISharePortfolioRequest
*/
func (a *PortfoliosAPIService) SharePortfolio(ctx context.Context, portfolioId string) PortfoliosAPISharePortfolioRequest {
	return PortfoliosAPISharePortfolioRequest{
		ApiService: a,
		ctx: ctx,
		portfolioId: portfolioId,
	}
}

// Execute executes the request
func (a *PortfoliosAPIService) SharePortfolioExecute(r PortfoliosAPISharePortfolioRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PortfoliosAPIService.SharePortfolio")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/portfolios/{portfolioId}/share"
	localVarPath = strings.Replace(localVarPath, "{"+"portfolioId"+"}", url.PathEscape(parameterValueToString(r.portfolioId, "portfolioId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accessRight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
