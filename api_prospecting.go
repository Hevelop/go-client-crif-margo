/*
Global Marketing Solution

## Overview

API version: 1.0.0
Contact: PM_Margo@crif.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package crifmargo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type ProspectingAPI interface {

	/*
	PostSearch Search companies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ProspectingAPIPostSearchRequest
	*/
	PostSearch(ctx context.Context) ProspectingAPIPostSearchRequest

	// PostSearchExecute executes the request
	//  @return SearchDataArrayMetadataType
	PostSearchExecute(r ProspectingAPIPostSearchRequest) (*SearchDataArrayMetadataType, *http.Response, error)
}

// ProspectingAPIService ProspectingAPI service
type ProspectingAPIService service

type ProspectingAPIPostSearchRequest struct {
	ctx context.Context
	ApiService ProspectingAPI
	acceptLanguage *string
	searchType *SearchType
}

// Set here the language you want in output
func (r ProspectingAPIPostSearchRequest) AcceptLanguage(acceptLanguage string) ProspectingAPIPostSearchRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// This method allows to search a list of prospect setting a series of filters and it could download companies&#39; data packets.  It&#39;s possible to search companies based on the value reported in the body: * &#x60;freeText&#x60;: search field that enables to find a company by name or identifier. * &#x60;ignoredPortfolios&#x60;: the array contains &#x60;portfoloIds&#x60; associated by the system to the portfolios (information are available using the method **GET /portfolios**). The method excludes from the response all the companies belong to the portfolios specifiend in the array. * &#x60;filters&#x60;: it contains all filter parameters linked to the companies&#39; business information. Parameters are grouped based on the data type: **numericFilters**, **dateFilters**, **booleanFilters**, **stringFilters**, **domainFilters**.  How can you perform a search? * if you search a specific company (e.g.: CRIF S.p.A.), you can insert in the body **only** the item &#x60;freeText&#x60;. * if you would like to search for a list of companies based on a subset of parameters, it&#39;s useful to insert in the body the items &#x60;ignoredPortfolios&#x60; and &#x60;filters&#x60; in order to perform the query (&#x60;freeText&#x60; might not present in the body).    In case you are going to use filter parameters provide by **POST /portfolios/{portfolioId}/create-similarity**, you should insert in &#x60;filters&#x60; the parameters provided by similarity method and &#x60;ignoredPortfolios&#x60; parameter should contain the **portfolioId** of the starting portfolio.   Data reported in the response depends by the presence of &#x60;content&#x60; item: * if the body doesn&#39;t contain it, the system provides a subset of information necessary to identify companies provided. * if the item is present, the system provides the data required based on the parameters: &#x60;dataPacketList&#x60; or &#x60;marketingList&#x60; (take a look: &#x60;content&#x60; must contain one of &#x60;dataPacketList&#x60; or &#x60;marketingList&#x60;). The first one is an array and each value must be the dataPacketId (for more details of the data packet availables go to the page **https://developer-cms.crifnet.com:8080/apis/margo/_**). &#x60;marketingList&#x60; enables the download of the company data with a fixed layout and it must be a string with a specific value (e.g. **marketing**).  An important parameter that handles the API response is the **continueToken**: it manages the number of calls based on the total number of companies searched and the pagination reported in the body of this method. The continueToken is provided after first call by Margo and it must be inserted in the body of next request. Moreover, it must be updated in the request body with the token returned by the previous response as it changes so as to identify each paginated response.  Finally, you could sorting the result by company name, turnover and  employee using the item &#x60;sort&#x60;. The format to use is &#x60;fieldId,(asc|desc)&#x60; and the fields are: * company name: **companyName** * turnover: **turnover** * employees: **employee**  Multiple sort criteria are not supported.
func (r ProspectingAPIPostSearchRequest) SearchType(searchType SearchType) ProspectingAPIPostSearchRequest {
	r.searchType = &searchType
	return r
}

func (r ProspectingAPIPostSearchRequest) Execute() (*SearchDataArrayMetadataType, *http.Response, error) {
	return r.ApiService.PostSearchExecute(r)
}

/*
PostSearch Search companies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProspectingAPIPostSearchRequest
*/
func (a *ProspectingAPIService) PostSearch(ctx context.Context) ProspectingAPIPostSearchRequest {
	return ProspectingAPIPostSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchDataArrayMetadataType
func (a *ProspectingAPIService) PostSearchExecute(r ProspectingAPIPostSearchRequest) (*SearchDataArrayMetadataType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchDataArrayMetadataType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProspectingAPIService.PostSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/prospecting/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "")
	}
	// body params
	localVarPostBody = r.searchType
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseErrorType
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
